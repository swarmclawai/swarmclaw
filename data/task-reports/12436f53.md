# Task 12436f53: Investigate message queue / context leaking between sessions

- Status: completed
- Agent: fcd98bac
- Session: e040343c

## Description
Wayde reports possible issues:
1. Context management tools exist but aren't accessible
2. Possible message queue issues
3. Context might be leaking between sessions

Need to investigate:
- Session isolation in message handling
- Context state management
- Tool registration/availability per session
- Message queues not properly scoped

Look at:
- src/lib/server/session-tools.ts (context tools)
- src/lib/server/orchestrator.ts (session handling)
- src/lib/server/stream-agent-chat.ts (message flow)
- Any shared state that could leak

## Result Summary
Here's what I found across all five areas. There are real issues:

---

## Investigation Results

### 1. Context Management Tools — Accessible but Gated

The `context_status` and `context_summarize` tools **do exist** (`session-tools.ts:2663` and `:2735`) but are only registered when the session has `manage_sessions` in its `tools` array (`session-tools.ts:2645`). If an agent isn't configured with `manage_sessions` enabled, these tools are invisible to it. This is likely the "tools exist but aren't accessible" issue — they need `manage_sessions` to be toggled on.

### 2. Race Condition in Message Persistence (CRITICAL)

`chat-execution.ts:283-525` has a classic read-modify-write race:

1. **Line 283-284**: `loadSessions()` → get `session` reference, push user message, save (line 320)
2. **Lines 355-377**: Long async LLM streaming happens with the **stale** `session` object
3. **Line 478**: `loadSessions()` again → gets `fresh` copy, pushes assistant message, saves (line 525)

If two concurrent chat requests hit the same session:
- Request A loads sessions, pushes user msg A, saves
- Request B loads sessions (includes msg A), pushes user msg B, saves  
- Request A finishes streaming, loads `fresh` (has msgs A+B), pushes assistant response A, saves
- Request B finishes streaming, loads `fresh` (has msgs A+B+assistantA), pushes assistant response B, saves

This mostly works **except**: if Request B's `fresh` load at line 478 happens *before* Request A's save at line 525, Request B's final save **overwrites** Request A's assistant message. Messages get lost.

### 3. Context Leak via Stale Session Object

The `session` object loaded at line 284 is passed directly to `streamAgentChat()` (line 359) and `provider.handler.streamChat()` (line 369). These functions **read from the session's in-memory fields** (like `session.messages`, `session.tools`, `session.provider`). However, `streamAgentChat` also calls `getSessionMessages(sessionId)` (line 365) which does a **fresh DB r

## Changed Files
- The `context_status` and `context_summarize` tools **do exist** (`session-tools.ts:2663` and `:2735`) but are only registered when the session has `manage_sessions` in its `tools` array (`session-tools.ts:2645`). If an agent isn't configured with `manage_sessions` enabled, these tools are invisible to it. This is likely the "tools exist but aren't accessible" issue — they need `manage_sessions` to be toggled on.
- `chat-execution.ts:283-525` has a classic read-modify-write race:

## Commands Run
- Not provided

## Verification
- The `session` object loaded at line 284 is passed directly to `streamAgentChat()` (line 359) and `provider.handler.streamChat()` (line 369). These functions **read from the session's in-memory fields** (like `session.messages`, `session.tools`, `session.provider`). However, `streamAgentChat` also calls `getSessionMessages(sessionId)` (line 365) which does a **fresh DB r
